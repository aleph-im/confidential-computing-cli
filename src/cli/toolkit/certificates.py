import hmac
from pathlib import Path
from typing import Dict, Tuple
from urllib.parse import urlparse
from uuid import UUID

from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

from cli.toolkit.sev.sevtool import generate_launch_blob as sevtool_generate_launch_blob

CERTIFICATES_DIR = Path.cwd() / "certificates"


def get_platform_certificates_dir(server_url: str) -> Path:
    hostname = urlparse(server_url).netloc
    return CERTIFICATES_DIR / "platforms" / hostname


def get_vm_certificates_dir(vm_id: str) -> Path:
    return CERTIFICATES_DIR / "vms" / vm_id


def generate_launch_blob(policy: str, server_url: str, vm_id: str) -> None:
    platform_certificates_dir = get_platform_certificates_dir(server_url)
    vm_certificates_dir = get_vm_certificates_dir(vm_id)
    sevtool_generate_launch_blob(platform_certificates_dir, vm_certificates_dir, policy)


def load_tik_tek_keys(vm_id: str) -> Tuple[bytes, bytes]:
    """
    Retrieves the Transport Integrity Key (TIK) and Transport Encryption Key (TEK)
    from the key file generated by sevtool.

    :param vm_id: ID of the VM.
    :return: A tuple with the TIK and TEK, in that order.
    """

    vm_certificates_dir = get_vm_certificates_dir(vm_id)
    key_file = vm_certificates_dir / "tmp_tk.bin"

    # The key file is just two concatenated 128-bit AES keys
    keys = key_file.read_bytes()
    tek = keys[0:16]
    tik = keys[16:32]

    return tik, tek


def compute_measure(
    sev_info: Dict, tik: bytes, expected_hash: str, nonce: bytes
) -> hmac.HMAC:

    h = hmac.new(tik, digestmod="sha256")

    ##
    # calculated per section 6.5.2
    ##
    h.update(bytes([0x04]))
    h.update(sev_info["api_major"].to_bytes(1, byteorder="little"))
    h.update(sev_info["api_minor"].to_bytes(1, byteorder="little"))
    h.update(sev_info["build_id"].to_bytes(1, byteorder="little"))
    h.update(int(sev_info["policy"], base=16).to_bytes(4, byteorder="little"))

    expected_hash_bytes = bytearray.fromhex(expected_hash)
    h.update(expected_hash_bytes)

    h.update(nonce)

    return h


def make_secret_table(disk_secret: str) -> bytearray:
    ##
    # construct the secret table: two guids + 4 byte lengths plus string
    # and zero terminator
    #
    # Secret layout is  guid, len (4 bytes), data
    # with len being the length from start of guid to end of data
    #
    # The table header covers the entire table then each entry covers
    # only its local data
    #
    # our current table has the header guid with total table length
    # followed by the secret guid with the zero terminated secret
    ##

    # total length of table: header plus one entry with trailing \0
    length = 16 + 4 + 16 + 4 + len(disk_secret) + 1
    # SEV-ES requires rounding to 16
    length = (length + 15) & ~15
    secret_table = bytearray(length)

    secret_table[0:16] = UUID("{1e74f542-71dd-4d66-963e-ef4287ff173b}").bytes_le
    secret_table[16:20] = len(secret_table).to_bytes(4, byteorder="little")
    secret_table[20:36] = UUID("{736869e5-84f0-4973-92ec-06879ce3da0b}").bytes_le
    secret_table[36:40] = (16 + 4 + len(disk_secret) + 1).to_bytes(
        4, byteorder="little"
    )
    secret_table[40: 40 + len(disk_secret)] = disk_secret.encode()

    return secret_table




def encrypt_secret_table(secret_table: bytes, tek: bytes, iv: bytes) -> bytes:
    """encrypt the secret table with the TEK in CTR mode using a random IV
    """

    # Initialize the cipher with AES algorithm and CTR mode
    cipher = Cipher(algorithms.AES(tek), modes.CTR(iv), backend=default_backend())
    encryptor = cipher.encryptor()

    # Encrypt the secret table
    encrypted_secret = encryptor.update(secret_table) + encryptor.finalize()

    return encrypted_secret


def make_packet_header(
    vm_measure: bytes,
    encrypted_secret_table: bytes,
    secret_table_size: int,
    tik: bytes,
    iv: bytes,
) -> bytearray:
    ##
    # ultimately needs to be an argument, but there's only
    # compressed and no real use case
    ##
    flags = 0

    ##
    # Table 55. LAUNCH_SECRET Packet Header Buffer
    ##
    header = bytearray(52)
    header[0:4] = flags.to_bytes(4, byteorder="little")
    header[4:20] = iv

    h = hmac.new(tik, digestmod="sha256")
    h.update(bytes([0x01]))
    # FLAGS || IV
    h.update(header[0:20])
    h.update(secret_table_size.to_bytes(4, byteorder="little"))
    h.update(secret_table_size.to_bytes(4, byteorder="little"))
    h.update(encrypted_secret_table)
    h.update(vm_measure)

    header[20:52] = h.digest()

    return header
